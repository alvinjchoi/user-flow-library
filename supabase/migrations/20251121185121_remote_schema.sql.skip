


SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;


COMMENT ON SCHEMA "public" IS 'standard public schema';



CREATE EXTENSION IF NOT EXISTS "pg_graphql" WITH SCHEMA "graphql";






CREATE EXTENSION IF NOT EXISTS "pg_stat_statements" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "pgcrypto" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "supabase_vault" WITH SCHEMA "vault";






CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA "extensions";






CREATE OR REPLACE FUNCTION "public"."generate_screen_path"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  parent_path TEXT;
BEGIN
  IF NEW.parent_id IS NULL THEN
    NEW.path := NEW.title;
    NEW.level := 0;
  ELSE
    SELECT path, level INTO parent_path, NEW.level
    FROM screens WHERE id = NEW.parent_id;
    NEW.path := parent_path || ' > ' || NEW.title;
    NEW.level := NEW.level + 1;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."generate_screen_path"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_flow_screen_count"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  IF TG_OP = 'DELETE' THEN
    UPDATE flows 
    SET screen_count = screen_count - 1,
        updated_at = NOW()
    WHERE id = OLD.flow_id;
    RETURN OLD;
  ELSIF TG_OP = 'INSERT' THEN
    UPDATE flows 
    SET screen_count = screen_count + 1,
        updated_at = NOW()
    WHERE id = NEW.flow_id;
    RETURN NEW;
  END IF;
  RETURN NULL;
END;
$$;


ALTER FUNCTION "public"."update_flow_screen_count"() OWNER TO "postgres";

SET default_tablespace = '';

SET default_table_access_method = "heap";


CREATE TABLE IF NOT EXISTS "public"."flows" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "project_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "order_index" integer DEFAULT 0,
    "screen_count" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "parent_screen_id" "uuid",
    "deleted_at" timestamp with time zone,
    "parent_flow_id" "uuid",
    CONSTRAINT "flows_not_self_parent" CHECK (("id" <> "parent_flow_id"))
);


ALTER TABLE "public"."flows" OWNER TO "postgres";


COMMENT ON COLUMN "public"."flows"."parent_flow_id" IS 'References another flow that this flow is nested under. Mutually exclusive with parent_screen_id.';



CREATE TABLE IF NOT EXISTS "public"."patterns" (
    "id" "text" NOT NULL,
    "title" "text" NOT NULL,
    "tags" "text"[] DEFAULT '{}'::"text"[] NOT NULL,
    "category" "text" NOT NULL,
    "screenshots" "text"[] DEFAULT '{}'::"text"[] NOT NULL,
    "description" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."patterns" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."projects" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "color" "text" DEFAULT '#3b82f6'::"text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "deleted_at" timestamp with time zone,
    "avatar_url" "text",
    "share_token" "text",
    "is_public" boolean DEFAULT false,
    "user_id" "text",
    "clerk_org_id" "text",
    "platform_type" "text" DEFAULT 'web'::"text",
    CONSTRAINT "projects_platform_type_check" CHECK (("platform_type" = ANY (ARRAY['web'::"text", 'ios'::"text", 'android'::"text"])))
);


ALTER TABLE "public"."projects" OWNER TO "postgres";


COMMENT ON COLUMN "public"."projects"."share_token" IS 'Unique token for public sharing of the project';



COMMENT ON COLUMN "public"."projects"."is_public" IS 'Whether the project is publicly accessible via share link';



COMMENT ON COLUMN "public"."projects"."user_id" IS 'Clerk user ID for personal projects (NULL for org projects)';



COMMENT ON COLUMN "public"."projects"."clerk_org_id" IS 'Clerk Organization ID - run ASSIGN_PROJECTS_TO_ORG.sql to assign existing projects';



COMMENT ON COLUMN "public"."projects"."platform_type" IS 'Platform type for the project: web, ios, or android. Determines screen dimensions.';



CREATE TABLE IF NOT EXISTS "public"."screen_comments" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "screen_id" "uuid" NOT NULL,
    "user_id" "text" NOT NULL,
    "user_name" "text",
    "user_avatar" "text",
    "x_position" numeric(5,2) NOT NULL,
    "y_position" numeric(5,2) NOT NULL,
    "comment_text" "text" NOT NULL,
    "is_resolved" boolean DEFAULT false,
    "parent_comment_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "resolved_at" timestamp with time zone,
    "resolved_by" "text",
    CONSTRAINT "screen_comments_x_position_check" CHECK ((("x_position" >= (0)::numeric) AND ("x_position" <= (100)::numeric))),
    CONSTRAINT "screen_comments_y_position_check" CHECK ((("y_position" >= (0)::numeric) AND ("y_position" <= (100)::numeric)))
);


ALTER TABLE "public"."screen_comments" OWNER TO "postgres";


COMMENT ON TABLE "public"."screen_comments" IS 'Stores user comments on screenshots with x,y coordinates for Figma-style annotations';



COMMENT ON COLUMN "public"."screen_comments"."resolved_at" IS 'Timestamp when the comment was resolved';



COMMENT ON COLUMN "public"."screen_comments"."resolved_by" IS 'Clerk user ID of the person who resolved the comment';



CREATE TABLE IF NOT EXISTS "public"."screen_hotspots" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "screen_id" "uuid" NOT NULL,
    "x_position" numeric(5,2) NOT NULL,
    "y_position" numeric(5,2) NOT NULL,
    "width" numeric(5,2) NOT NULL,
    "height" numeric(5,2) NOT NULL,
    "element_type" "text",
    "element_label" "text",
    "element_description" "text",
    "target_screen_id" "uuid",
    "interaction_type" "text" DEFAULT 'navigate'::"text",
    "confidence_score" numeric(3,2),
    "is_ai_generated" boolean DEFAULT false,
    "order_index" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "screen_hotspots_confidence_score_check" CHECK ((("confidence_score" >= (0)::numeric) AND ("confidence_score" <= (1)::numeric))),
    CONSTRAINT "screen_hotspots_element_type_check" CHECK (("element_type" = ANY (ARRAY['button'::"text", 'link'::"text", 'card'::"text", 'tab'::"text", 'input'::"text", 'icon'::"text", 'other'::"text"]))),
    CONSTRAINT "screen_hotspots_height_check" CHECK ((("height" >= (0)::numeric) AND ("height" <= (100)::numeric))),
    CONSTRAINT "screen_hotspots_interaction_type_check" CHECK (("interaction_type" = ANY (ARRAY['navigate'::"text", 'overlay'::"text", 'replace'::"text", 'back'::"text"]))),
    CONSTRAINT "screen_hotspots_width_check" CHECK ((("width" >= (0)::numeric) AND ("width" <= (100)::numeric))),
    CONSTRAINT "screen_hotspots_x_position_check" CHECK ((("x_position" >= (0)::numeric) AND ("x_position" <= (100)::numeric))),
    CONSTRAINT "screen_hotspots_y_position_check" CHECK ((("y_position" >= (0)::numeric) AND ("y_position" <= (100)::numeric)))
);


ALTER TABLE "public"."screen_hotspots" OWNER TO "postgres";


COMMENT ON TABLE "public"."screen_hotspots" IS 'Interactive hotspots for creating clickable prototypes. Each hotspot defines a clickable area on a screenshot that can navigate to another screen.';



COMMENT ON COLUMN "public"."screen_hotspots"."x_position" IS 'Horizontal position from left as percentage (0-100)';



COMMENT ON COLUMN "public"."screen_hotspots"."y_position" IS 'Vertical position from top as percentage (0-100)';



COMMENT ON COLUMN "public"."screen_hotspots"."width" IS 'Width as percentage of image width (0-100)';



COMMENT ON COLUMN "public"."screen_hotspots"."height" IS 'Height as percentage of image height (0-100)';



COMMENT ON COLUMN "public"."screen_hotspots"."confidence_score" IS 'AI confidence score for auto-detected elements (0.00-1.00)';



CREATE TABLE IF NOT EXISTS "public"."screen_inspirations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "screen_id" "uuid",
    "related_screen_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."screen_inspirations" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."screens" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "flow_id" "uuid" NOT NULL,
    "parent_id" "uuid",
    "title" "text" NOT NULL,
    "screenshot_url" "text",
    "notes" "text",
    "order_index" integer DEFAULT 0,
    "level" integer DEFAULT 0,
    "path" "text",
    "tags" "text"[] DEFAULT '{}'::"text"[],
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "display_name" "text",
    "deleted_at" timestamp with time zone
);


ALTER TABLE "public"."screens" OWNER TO "postgres";


COMMENT ON COLUMN "public"."screens"."display_name" IS 'Action-oriented name for sidebar display (e.g., "Searching Reddit"). Falls back to title if not set.';



ALTER TABLE ONLY "public"."flows"
    ADD CONSTRAINT "flows_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."patterns"
    ADD CONSTRAINT "patterns_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."projects"
    ADD CONSTRAINT "projects_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."projects"
    ADD CONSTRAINT "projects_share_token_key" UNIQUE ("share_token");



ALTER TABLE ONLY "public"."screen_comments"
    ADD CONSTRAINT "screen_comments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."screen_hotspots"
    ADD CONSTRAINT "screen_hotspots_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."screen_inspirations"
    ADD CONSTRAINT "screen_inspirations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."screens"
    ADD CONSTRAINT "screens_pkey" PRIMARY KEY ("id");



CREATE INDEX "idx_flows_deleted_at" ON "public"."flows" USING "btree" ("deleted_at");



CREATE INDEX "idx_flows_order" ON "public"."flows" USING "btree" ("project_id", "order_index");



CREATE INDEX "idx_flows_parent_flow_id" ON "public"."flows" USING "btree" ("parent_flow_id");



CREATE INDEX "idx_flows_parent_screen_id" ON "public"."flows" USING "btree" ("parent_screen_id");



CREATE INDEX "idx_flows_project_id" ON "public"."flows" USING "btree" ("project_id");



CREATE INDEX "idx_hotspots_order" ON "public"."screen_hotspots" USING "btree" ("screen_id", "order_index");



CREATE INDEX "idx_hotspots_screen" ON "public"."screen_hotspots" USING "btree" ("screen_id");



CREATE INDEX "idx_hotspots_target" ON "public"."screen_hotspots" USING "btree" ("target_screen_id");



CREATE INDEX "idx_patterns_category" ON "public"."patterns" USING "btree" ("category");



CREATE INDEX "idx_patterns_created_at" ON "public"."patterns" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_patterns_tags" ON "public"."patterns" USING "gin" ("tags");



CREATE INDEX "idx_projects_avatar_url" ON "public"."projects" USING "btree" ("avatar_url");



CREATE INDEX "idx_projects_clerk_org_id" ON "public"."projects" USING "btree" ("clerk_org_id");



CREATE INDEX "idx_projects_created_at" ON "public"."projects" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_projects_deleted_at" ON "public"."projects" USING "btree" ("deleted_at");



CREATE INDEX "idx_projects_platform_type" ON "public"."projects" USING "btree" ("platform_type");



CREATE INDEX "idx_projects_share_token" ON "public"."projects" USING "btree" ("share_token") WHERE ("share_token" IS NOT NULL);



CREATE INDEX "idx_projects_user_id" ON "public"."projects" USING "btree" ("user_id");



CREATE INDEX "idx_screen_comments_parent_id" ON "public"."screen_comments" USING "btree" ("parent_comment_id");



CREATE INDEX "idx_screen_comments_resolved" ON "public"."screen_comments" USING "btree" ("is_resolved", "resolved_at") WHERE ("is_resolved" = true);



CREATE INDEX "idx_screen_comments_screen_id" ON "public"."screen_comments" USING "btree" ("screen_id");



CREATE INDEX "idx_screen_comments_user_id" ON "public"."screen_comments" USING "btree" ("user_id");



CREATE INDEX "idx_screens_deleted_at" ON "public"."screens" USING "btree" ("deleted_at");



CREATE INDEX "idx_screens_flow_id" ON "public"."screens" USING "btree" ("flow_id");



CREATE INDEX "idx_screens_parent_id" ON "public"."screens" USING "btree" ("parent_id");



CREATE INDEX "idx_screens_path" ON "public"."screens" USING "gin" ("to_tsvector"('"english"'::"regconfig", "path"));



CREATE INDEX "idx_screens_tags" ON "public"."screens" USING "gin" ("tags");



CREATE OR REPLACE TRIGGER "trigger_generate_path" BEFORE INSERT OR UPDATE ON "public"."screens" FOR EACH ROW EXECUTE FUNCTION "public"."generate_screen_path"();



CREATE OR REPLACE TRIGGER "trigger_update_screen_count" AFTER INSERT OR DELETE ON "public"."screens" FOR EACH ROW EXECUTE FUNCTION "public"."update_flow_screen_count"();



ALTER TABLE ONLY "public"."flows"
    ADD CONSTRAINT "flows_parent_flow_id_fkey" FOREIGN KEY ("parent_flow_id") REFERENCES "public"."flows"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."flows"
    ADD CONSTRAINT "flows_parent_screen_id_fkey" FOREIGN KEY ("parent_screen_id") REFERENCES "public"."screens"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."flows"
    ADD CONSTRAINT "flows_project_id_fkey" FOREIGN KEY ("project_id") REFERENCES "public"."projects"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."screen_comments"
    ADD CONSTRAINT "screen_comments_parent_comment_id_fkey" FOREIGN KEY ("parent_comment_id") REFERENCES "public"."screen_comments"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."screen_comments"
    ADD CONSTRAINT "screen_comments_screen_id_fkey" FOREIGN KEY ("screen_id") REFERENCES "public"."screens"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."screen_hotspots"
    ADD CONSTRAINT "screen_hotspots_screen_id_fkey" FOREIGN KEY ("screen_id") REFERENCES "public"."screens"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."screen_hotspots"
    ADD CONSTRAINT "screen_hotspots_target_screen_id_fkey" FOREIGN KEY ("target_screen_id") REFERENCES "public"."screens"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."screen_inspirations"
    ADD CONSTRAINT "screen_inspirations_related_screen_id_fkey" FOREIGN KEY ("related_screen_id") REFERENCES "public"."screens"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."screen_inspirations"
    ADD CONSTRAINT "screen_inspirations_screen_id_fkey" FOREIGN KEY ("screen_id") REFERENCES "public"."screens"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."screens"
    ADD CONSTRAINT "screens_flow_id_fkey" FOREIGN KEY ("flow_id") REFERENCES "public"."flows"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."screens"
    ADD CONSTRAINT "screens_parent_id_fkey" FOREIGN KEY ("parent_id") REFERENCES "public"."screens"("id") ON DELETE CASCADE;



CREATE POLICY "Allow public delete" ON "public"."patterns" FOR DELETE USING (true);



CREATE POLICY "Allow public insert" ON "public"."patterns" FOR INSERT WITH CHECK (true);



CREATE POLICY "Allow public read access" ON "public"."patterns" FOR SELECT USING (true);



CREATE POLICY "Allow public update" ON "public"."patterns" FOR UPDATE USING (true);



CREATE POLICY "Authenticated users can create comments" ON "public"."screen_comments" FOR INSERT WITH CHECK (("auth"."jwt"() IS NOT NULL));



CREATE POLICY "Enable delete for authenticated users" ON "public"."screen_hotspots" FOR DELETE TO "authenticated" USING (true);



CREATE POLICY "Enable insert for authenticated users" ON "public"."screen_hotspots" FOR INSERT TO "authenticated" WITH CHECK (true);



CREATE POLICY "Enable read access for authenticated users" ON "public"."screen_hotspots" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Enable update for authenticated users" ON "public"."screen_hotspots" FOR UPDATE TO "authenticated" USING (true) WITH CHECK (true);



CREATE POLICY "Users can create flows" ON "public"."flows" FOR INSERT WITH CHECK (("deleted_at" IS NULL));



CREATE POLICY "Users can create screens" ON "public"."screens" FOR INSERT WITH CHECK (("deleted_at" IS NULL));



CREATE POLICY "Users can delete flows" ON "public"."flows" FOR UPDATE USING (("deleted_at" IS NULL));



CREATE POLICY "Users can delete screens" ON "public"."screens" FOR UPDATE USING (("deleted_at" IS NULL));



CREATE POLICY "Users can delete their own comments" ON "public"."screen_comments" FOR DELETE USING (("user_id" = ("auth"."jwt"() ->> 'sub'::"text")));



CREATE POLICY "Users can update flows" ON "public"."flows" FOR UPDATE USING (("deleted_at" IS NULL));



CREATE POLICY "Users can update own comments or resolve any" ON "public"."screen_comments" FOR UPDATE USING ((("user_id" = ("auth"."jwt"() ->> 'sub'::"text")) OR ("auth"."jwt"() IS NOT NULL)));



COMMENT ON POLICY "Users can update own comments or resolve any" ON "public"."screen_comments" IS 'Allows users to edit their own comments, but any authenticated user can resolve/unresolve any comment (Figma-style)';



CREATE POLICY "Users can update screens" ON "public"."screens" FOR UPDATE USING (("deleted_at" IS NULL));



CREATE POLICY "Users can view comments on accessible screens" ON "public"."screen_comments" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM ("public"."screens" "s"
     JOIN "public"."flows" "f" ON (("s"."flow_id" = "f"."id")))
  WHERE ("s"."id" = "screen_comments"."screen_id"))));



CREATE POLICY "Users can view flows" ON "public"."flows" FOR SELECT USING (("deleted_at" IS NULL));



CREATE POLICY "Users can view screens" ON "public"."screens" FOR SELECT USING (("deleted_at" IS NULL));



CREATE POLICY "delete_projects" ON "public"."projects" FOR UPDATE TO "authenticated" USING (((("auth"."jwt"() ->> 'sub'::"text") = "user_id") OR ((("auth"."jwt"() -> 'org_id'::"text"))::"text" = "clerk_org_id")));



ALTER TABLE "public"."flows" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "insert_projects" ON "public"."projects" FOR INSERT TO "authenticated" WITH CHECK ((("auth"."jwt"() ->> 'sub'::"text") = "user_id"));



ALTER TABLE "public"."patterns" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "public_delete_flows" ON "public"."flows" FOR DELETE USING (true);



CREATE POLICY "public_delete_screens" ON "public"."screens" FOR DELETE USING (true);



CREATE POLICY "public_insert_flows" ON "public"."flows" FOR INSERT WITH CHECK (true);



CREATE POLICY "public_insert_screens" ON "public"."screens" FOR INSERT WITH CHECK (true);



CREATE POLICY "public_read_flows" ON "public"."flows" FOR SELECT USING (true);



CREATE POLICY "public_read_screens" ON "public"."screens" FOR SELECT USING (true);



CREATE POLICY "public_update_flows" ON "public"."flows" FOR UPDATE USING (true);



CREATE POLICY "public_update_screens" ON "public"."screens" FOR UPDATE USING (true);



ALTER TABLE "public"."screen_comments" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."screen_hotspots" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."screens" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "select_projects_by_user_or_org" ON "public"."projects" FOR SELECT TO "authenticated" USING (((("auth"."jwt"() ->> 'sub'::"text") = "user_id") OR ((("auth"."jwt"() -> 'org_id'::"text"))::"text" = "clerk_org_id")));



CREATE POLICY "update_projects" ON "public"."projects" FOR UPDATE TO "authenticated" USING (((("auth"."jwt"() ->> 'sub'::"text") = "user_id") OR ((("auth"."jwt"() -> 'org_id'::"text"))::"text" = "clerk_org_id"))) WITH CHECK (((("auth"."jwt"() ->> 'sub'::"text") = "user_id") OR ((("auth"."jwt"() -> 'org_id'::"text"))::"text" = "clerk_org_id")));





ALTER PUBLICATION "supabase_realtime" OWNER TO "postgres";


GRANT USAGE ON SCHEMA "public" TO "postgres";
GRANT USAGE ON SCHEMA "public" TO "anon";
GRANT USAGE ON SCHEMA "public" TO "authenticated";
GRANT USAGE ON SCHEMA "public" TO "service_role";

























































































































































GRANT ALL ON FUNCTION "public"."generate_screen_path"() TO "anon";
GRANT ALL ON FUNCTION "public"."generate_screen_path"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_screen_path"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_flow_screen_count"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_flow_screen_count"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_flow_screen_count"() TO "service_role";


















GRANT ALL ON TABLE "public"."flows" TO "anon";
GRANT ALL ON TABLE "public"."flows" TO "authenticated";
GRANT ALL ON TABLE "public"."flows" TO "service_role";



GRANT ALL ON TABLE "public"."patterns" TO "anon";
GRANT ALL ON TABLE "public"."patterns" TO "authenticated";
GRANT ALL ON TABLE "public"."patterns" TO "service_role";



GRANT ALL ON TABLE "public"."projects" TO "anon";
GRANT ALL ON TABLE "public"."projects" TO "authenticated";
GRANT ALL ON TABLE "public"."projects" TO "service_role";



GRANT ALL ON TABLE "public"."screen_comments" TO "anon";
GRANT ALL ON TABLE "public"."screen_comments" TO "authenticated";
GRANT ALL ON TABLE "public"."screen_comments" TO "service_role";



GRANT ALL ON TABLE "public"."screen_hotspots" TO "anon";
GRANT ALL ON TABLE "public"."screen_hotspots" TO "authenticated";
GRANT ALL ON TABLE "public"."screen_hotspots" TO "service_role";



GRANT ALL ON TABLE "public"."screen_inspirations" TO "anon";
GRANT ALL ON TABLE "public"."screen_inspirations" TO "authenticated";
GRANT ALL ON TABLE "public"."screen_inspirations" TO "service_role";



GRANT ALL ON TABLE "public"."screens" TO "anon";
GRANT ALL ON TABLE "public"."screens" TO "authenticated";
GRANT ALL ON TABLE "public"."screens" TO "service_role";









ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "service_role";































